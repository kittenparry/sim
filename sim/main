#!/usr/bin/env python3

# for Windows need: python -m pip install windows-curses

import sys
import curses
import datetime

from Human import Human
from World import World
from Food import food_tiles
from Shelter import shelter_tiles

IND_HUM = 'â˜»'  # human indicator
IND_FOOD = '+' # food indicator
IND_SHEL = '@' # shelter indicator

PAD_HOR = World.width + 2  # horizontal padding

def main():
	population = 25
	humans = []
	for i in range(population):
		humans.append(Human('Adam'))

	world = []
	for x in range(World.height):
		temp = []
		for y in range(World.width):
			temp.append([' '])
		world.append(temp)


	stdscr = curses.initscr()
	curses.start_color()
	curses.use_default_colors()
	curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_GREEN)
	curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_RED)
	curses.cbreak() # this enables keys working by themselves without enter
	stdscr.keypad(1) # this enables listening for keys
	stdscr.nodelay(1) # removes wait for getch()

	stdscr.addstr(0, PAD_HOR, 'Hit \'q\' to quit.')
	stdscr.addstr(1, PAD_HOR, 'Words sound so hollow in the cold.')
	stdscr.refresh()

	position_food(world)
	position_shelter(world)

	secs = 0
	layer = 0
	key = ''
	while key != ord('q'):
		# to draw different layers
		if layer >= 3:
			layer = 0
		key = stdscr.getch()
		stdscr.addstr(2, PAD_HOR, 'Time: %s' % datetime.timedelta(seconds=secs))
		stdscr.addstr(3, PAD_HOR, 'Layer: %d' % layer)
		check_if_dead(humans)
		stdscr.addstr(4, PAD_HOR, 'Population: %d   ' % len(humans))
		# FIXME: temporary grave display
		stdscr.addstr(5, PAD_HOR, 'Grave: %s' % ((population - len(humans)) * 'X'))
		position_humans(world, humans)
		draw_map(stdscr, world, layer)
		print_stats_humans(stdscr, world, humans)
		move_humans(world, humans)

		stdscr.refresh()
		curses.napms(1000) # delays input rather than letting them skip cycle, including q
		layer += 1
		secs += 1

	curses.endwin()


def draw_map(stdscr, world, layer):
	for y in range(len(world)):
		for i, x in enumerate(world[y]):
			# replace empty tiles in shelter/food tiles so it flickers with humans on them
			# currently this assumes food and shelter are eternal
			if IND_SHEL in x and ' ' in x:
				x[0] = IND_SHEL
				del x[1]
			if IND_FOOD in x and ' ' in x:
				x[0] = IND_FOOD
				del x[1]
			# so it only flickers on tiles with shelter/food rather than empty tiles
			if IND_HUM in x and ' ' in x:
				obj = IND_HUM
			else:
				obj = x[layer] if layer < len(x) else x[-1]
			stdscr.addstr(y, i, str(obj), curses.color_pair(1))

# HUMANS
def position_humans(world, humans):
	for h in humans:
		world[h.pos_y][h.pos_x].append(IND_HUM)

def move_humans(world, humans):
	for h in humans:
		# remove all instances of human indicator from that position
		while IND_HUM in world[h.pos_y][h.pos_x]:
			world[h.pos_y][h.pos_x].remove(IND_HUM)
		h.decrease_needs()
		h.check_needs()
		h.move_around()

def check_if_dead(humans):
	for h in humans:
		if h.is_dead:
			humans.remove(h)
			# TODO: grave mark at some point
			# world[h.pos_y][h.pos_x].append('x')

# FOOD
def position_food(world):
	for f in food_tiles:
		world[f.pos_y][f.pos_x].append(IND_FOOD)

# SHELTER
def position_shelter(world):
	for s in shelter_tiles:
		world[s.pos_y][s.pos_x].append(IND_SHEL)

# UI
def print_stats_humans(stdscr, world, humans):
	stdscr.addstr(World.height, 0, World.width * 2 * '-' + '-----')
	err = 0
	for i, h in enumerate(humans):
		info = ' %d. %s - H: %02d S: %02d - %02d, %02d - %s' % (i + 1, h.name, h.need_hunger, h.need_sleep, h.pos_x, h.pos_y, h.status)
		try:
			stdscr.addstr(World.height + i + 1, 0, info)
		except curses.error:
			if err == 0:
				err = World.height + i
	# TODO: maybe scroll down and up the list with arrow keys
	if err > 0:
		stdscr.addstr(err, 0, World.width * '-' + ' ... ' + World.width * '-')


if __name__ == '__main__':
	main()
