#!/usr/bin/env python3

# for Windows need: python -m pip install windows-curses

import sys
import curses
import datetime

from Human import Human
from World import World
from Food import food_tiles
from Shelter import shelter_tiles

IND_HUM = '☺'  # human indicator
IND_FOOD = '♣' # food indicator
IND_SHEL = '▓' # shelter indicator

PAD_HOR = World.width + 2  # horizontal padding

def main():
	population = 25
	humans = []
	for i in range(population):
		humans.append(Human())

	world = []
	for x in range(World.height):
		temp = []
		for y in range(World.width):
			temp.append([' '])
		world.append(temp)


	stdscr = curses.initscr()
	curses.start_color()
	curses.use_default_colors()
	curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_GREEN)
	curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_RED)
	curses.cbreak() # this enables keys working by themselves without enter
	stdscr.keypad(1) # this enables listening for keys
	stdscr.nodelay(1) # removes wait for getch()

	stdscr.addstr(0, PAD_HOR, 'Hit \'q\' to quit.')
	stdscr.addstr(1, PAD_HOR, 'Words sound so hollow in the cold.')
	stdscr.refresh()

	position_food(world)
	position_shelter(world)

	char_key = 0
	secs = 0
	layer = 0
	key = ''
	while key != ord('q'):
		# to draw different layers
		if layer >= 3:
			layer = 0
		key = stdscr.getch()
		stdscr.addstr(2, PAD_HOR, 'Time: %s' % datetime.timedelta(seconds=secs))
		stdscr.addstr(3, PAD_HOR, 'Layer: %d' % layer)
		check_if_dead(humans)
		stdscr.addstr(4, PAD_HOR, 'Population: %d   ' % len(humans))
		# FIXME: temporary grave display
		stdscr.addstr(5, PAD_HOR, 'Grave: %s' % ((population - len(humans)) * 'X'))
		stdscr.addstr(6, PAD_HOR, 'key: %s  ' % key)
		position_humans(world, humans)
		draw_map(stdscr, world, layer)

		if key > 48 and key < 58: # 1-9 for now?
			char_key = key
		elif key == ord('c'):
			char_key = 0

		if char_key > 48 and char_key < 58:
			try:
				draw_human_info(stdscr, humans, char_key)
			except IndexError:
				char_key = 0
		else:
			print_stats_humans(stdscr, world, humans)

		move_humans(world, humans)

		stdscr.refresh()
		curses.napms(1000) # delays input rather than letting them skip cycle, including q
		layer += 1
		secs += 1

	curses.endwin()


def draw_map(stdscr, world, layer):
	for y in range(len(world)):
		for i, x in enumerate(world[y]):
			# replace empty tiles in shelter/food tiles so it flickers with humans on them
			# currently this assumes food and shelter are eternal
			if IND_SHEL in x and ' ' in x:
				x[0] = IND_SHEL
				del x[1]
			if IND_FOOD in x and ' ' in x:
				x[0] = IND_FOOD
				del x[1]
			# so it only flickers on tiles with shelter/food rather than empty tiles
			if IND_HUM in x and ' ' in x:
				obj = IND_HUM
			else:
				obj = x[layer] if layer < len(x) else x[-1]
			stdscr.addstr(y, i, str(obj), curses.color_pair(1))

# HUMANS
def position_humans(world, humans):
	for h in humans:
		world[h.pos_y][h.pos_x].append(IND_HUM)

def move_humans(world, humans):
	for h in humans:
		# remove all instances of human indicator from that position
		while IND_HUM in world[h.pos_y][h.pos_x]:
			world[h.pos_y][h.pos_x].remove(IND_HUM)
		h.decrease_needs()
		h.check_needs()
		h.move_around()

def check_if_dead(humans):
	for h in humans:
		if h.is_dead:
			humans.remove(h)
			# TODO: grave mark at some point
			# world[h.pos_y][h.pos_x].append('x')

# FOOD
def position_food(world):
	for f in food_tiles:
		world[f.pos_y][f.pos_x].append(IND_FOOD)

# SHELTER
def position_shelter(world):
	for s in shelter_tiles:
		world[s.pos_y][s.pos_x].append(IND_SHEL)

# UI
def print_stats_humans(stdscr, world, humans):
	clear_info_screen(stdscr)
	err = 0
	for i, h in enumerate(humans):
		info = '%d. %s %s %s. - H: %02d S: %02d - %02d, %02d - %s' % (i + 1, h.gender_glyph, h.name, h.surname, h.need_hunger, h.need_sleep, h.pos_x, h.pos_y, h.status)
		try:
			stdscr.addstr(World.height + i + 1, 2, info)
		except curses.error:
			if err == 0:
				err = World.height + i
		
		if err > 0:
			bot = ' ... '
		else:
			bot = ''
		draw_box(stdscr, World.width * 2, len(humans) + 1, bot_text = bot)
	# TODO: maybe scroll down and up the list with arrow keys

def draw_human_info(stdscr, humans, key):
	key = key - 48
	h = humans[key - 1]
	clear_info_screen(stdscr)
	draw_box(stdscr, World.width, 8, '(c)ancel')
	stdscr.addstr(World.height + 2, 1, ' name: %s %s.' % (h.name, h.surname))
	stdscr.addstr(World.height + 3, 1, ' age: %d gender: %s %s ' % (h.age, h.gender, h.gender_glyph))
	stdscr.addstr(World.height + 4, 1, ' hunger: %03d sleep: %03d' % (h.need_hunger, h.need_sleep))
	stdscr.addstr(World.height + 5, 1, ' position: %d, %d' % (h.pos_x, h.pos_y))
	stdscr.addstr(World.height + 6, 1, ' status: %s' % h.status)


def clear_info_screen(stdscr):
	for y in range(100):
		for x in range(100):
			try:
				stdscr.addstr(World.height + y, x, ' ')
			except curses.error:
				pass

def draw_box(stdscr, width, height, top_text = '', bot_text = ''):
	top_line = '╔═%s═' % top_text + (width - len(top_text) - 2  if width - len(top_text) - 2 >= 0 else 0) * '═' + '╗'
	stdscr.addstr(World.height, 0, top_line)
	last_i = -1
	for i in range(height):
		try:
			stdscr.addstr(World.height + i + 1, 0, '║')
			stdscr.addstr(World.height + i + 1, len(top_line) - 1, '║')
		except curses.error:
			if last_i == -1:
				last_i = i
	# if height is less than last drawing height, last_i = height
	# or if last_i is -1, it should be equal to height since there were no errors
	last_i = height if height <= last_i or last_i == -1 else last_i
	bot_line = '╚═%s═' % bot_text + (width - len(bot_text) - 2  if width - len(bot_text) - 2 >= 0 else 0) * '═' + '╝'
	stdscr.addstr(World.height + last_i, 0, bot_line)

if __name__ == '__main__':
	main()
