#!/usr/bin/env python3

# for Windows need: python -m pip install windows-curses

import sys
import curses

from Human import Human
from World import World
from Food import food_tiles

IND_HUM = 'O'  # human indicator
IND_FOOD = '+' # food indicator

PAD_HOR = World.width + 2  # horizontal padding

def main():
	population = 1
	humans = []
	for i in range(population):
		humans.append(Human('Adam'))

	world = []
	for x in range(World.height):
		temp = []
		for y in range(World.width):
			temp.append([' '])
		world.append(temp)


	stdscr = curses.initscr()
	curses.start_color()
	curses.use_default_colors()
	curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_GREEN)
	curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_RED)
	curses.cbreak() # this enables keys working by themselves without enter
	stdscr.keypad(1) # this enables listening for keys
	stdscr.nodelay(1) # removes wait for getch()

	stdscr.addstr(0, PAD_HOR, 'Hit \'q\' to quit.')
	stdscr.addstr(1, PAD_HOR, 'Words sound so hollow in the cold.')
	stdscr.refresh()

	position_food(world, food_tiles)
	layer = 0;
	key = ''
	while key != ord('q'):
		# to draw different layers
		if layer >= 3:
			layer = 0
		key = stdscr.getch()
		stdscr.addstr(2, PAD_HOR, 'Layer: %d' % layer)
		position_humans(world, humans)
		draw_map(stdscr, world, layer)
		print_stats_humans(stdscr, world, humans)
		move_humans(world, humans)

		stdscr.refresh()
		curses.napms(1000) # delays input rather than letting them skip cycle, including q
		layer += 1

	curses.endwin()


def draw_map(stdscr, world, layer):
	for y in range(len(world)):
		for i, x in enumerate(world[y]):
			if IND_HUM in x:
				obj = IND_HUM
			elif IND_FOOD in x and ' ' in x:
				obj = IND_FOOD
			else:
				obj = x[layer] if layer < len(x) else x[-1]
			stdscr.addstr(y, i, str(obj), curses.color_pair(1))

# HUMANS
def position_humans(world, humans):
	for h in humans:
		world[h.pos_y][h.pos_x].append(IND_HUM)

def move_humans(world, humans):
	for h in humans:
		# remove all instances of human indicator from that position
		while IND_HUM in world[h.pos_y][h.pos_x]:
			world[h.pos_y][h.pos_x].remove(IND_HUM)
		h.decrease_needs()
		h.check_needs()
		h.move_around()

# FOOD
def position_food(world, food):
	for f in food:
		world[f.pos_y][f.pos_x].append(IND_FOOD)

# UI
def print_stats_humans(stdscr, world, humans):
	stdscr.addstr(World.height, 0, World.width * '-')
	for i, h in enumerate(humans):
		info = '%d. %s - H: %02d S: %02d - %02d, %02d - E: %s S: %s - %s' % (i + 1, h.name, h.need_hunger, h.need_sleep, h.pos_x, h.pos_y, str(h.is_eating), str(h.is_sleeping), h.status)
		stdscr.addstr(World.height + i + 1, 0, info)


if __name__ == '__main__':
	main()
